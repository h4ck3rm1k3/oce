// This file is generated by WOK (CPPExt).
// Please do not edit this file; modify original file instead.
// The copyright and license terms as defined for the original file apply to 
// this header file considered to be the "object code" form of the original source.

#ifndef _ShapePlacement_ConstraintAlgo_HeaderFile
#define _ShapePlacement_ConstraintAlgo_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

#ifndef _Standard_Boolean_HeaderFile
#include <Standard_Boolean.hxx>
#endif
#ifndef _gp_Trsf_HeaderFile
#include <gp_Trsf.hxx>
#endif
#ifndef _Handle_TColStd_HArray1OfInteger_HeaderFile
#include <Handle_TColStd_HArray1OfInteger.hxx>
#endif
#ifndef _Standard_Real_HeaderFile
#include <Standard_Real.hxx>
#endif
#ifndef _ShapePlacement_ListOfConstraint_HeaderFile
#include <ShapePlacement_ListOfConstraint.hxx>
#endif
#ifndef _TopoDS_Shape_HeaderFile
#include <TopoDS_Shape.hxx>
#endif
#ifndef _TopTools_IndexedMapOfShape_HeaderFile
#include <TopTools_IndexedMapOfShape.hxx>
#endif
#ifndef _Standard_Integer_HeaderFile
#include <Standard_Integer.hxx>
#endif
#ifndef _ShapePlacement_TypeOfConstraint_HeaderFile
#include <ShapePlacement_TypeOfConstraint.hxx>
#endif
#ifndef _ShapePlacement_TypeOfAxisConstraint_HeaderFile
#include <ShapePlacement_TypeOfAxisConstraint.hxx>
#endif
#ifndef _Standard_OStream_HeaderFile
#include <Standard_OStream.hxx>
#endif
class TColStd_HArray1OfInteger;
class TopoDS_Shape;
class gp_Trsf;
class gp_Pnt;
class ShapePlacement_ListOfConstraint;
class ShapePlacement_Constraint;



class ShapePlacement_ConstraintAlgo  {
public:

  void* operator new(size_t,void* anAddress) 
  {
    return anAddress;
  }
  void* operator new(size_t size) 
  {
    return Standard::Allocate(size); 
  }
  void  operator delete(void *anAddress) 
  {
    if (anAddress) Standard::Free((Standard_Address&)anAddress); 
  }

  //! Undefined Algo. <br>
//! <br>
  Standard_EXPORT   ShapePlacement_ConstraintAlgo(const Standard_Real AngularTolerance = 1.0e-6);
  //! Undefined Algo. <br>
//! <br>
  Standard_EXPORT   ShapePlacement_ConstraintAlgo(const TopoDS_Shape& S,const Standard_Real AngularTolerance);
  //! Set the field MyShapeToPosition to S <br>
//! this metyhod is only needed for tests with Draw <br>
//! <br>
  Standard_EXPORT     void Load(const TopoDS_Shape& S) ;
  //! This methode returns true when there is a solution <br>
//!          and false in the other cases. <br>
  Standard_EXPORT     Standard_Boolean HasSolution() const;
  //! This methode returns the transformation associated <br>
//!          to the set of constraints. <br>
  Standard_EXPORT     gp_Trsf GetTrsf() const;
  //! This methode tries to  find a solution for the set <br>
//!          of   constraints. <br>
  Standard_EXPORT     void Solve() ;
  //! This methode add a constraint to the set of constraint. <br>
//!          a SubShape is a sub element of the shape to place. <br>
  Standard_EXPORT     Standard_Integer AddConstraint(const ShapePlacement_TypeOfConstraint aKeyWord,const TopoDS_Shape& aSubShape,const ShapePlacement_TypeOfAxisConstraint aSubAxis,const TopoDS_Shape& aFixedShape,const ShapePlacement_TypeOfAxisConstraint aFixedAxis) ;
  //! This methode add a constraint to the set of constraint. <br>
//!          a SubShape is a sub element of the shape to place. <br>
  Standard_EXPORT     Standard_Integer AddConstraint(const ShapePlacement_TypeOfConstraint aKeyWord,const TopoDS_Shape& aSubShape,const ShapePlacement_TypeOfAxisConstraint aSubAxis,const TopoDS_Shape& aFixedShape,const ShapePlacement_TypeOfAxisConstraint aFixedAxis,const Standard_Real aCotation) ;
  
//!  sets the angular tolerance <br>
//! <br>
//! <br>
  Standard_EXPORT     void SetTolerance(const Standard_Real AngularTolerance) ;
  //! This methode prints the set of constraint. <br>
  Standard_EXPORT     void PrintConstraint(Standard_OStream& S) const;
  //! returns the shape to position <br>
//! <br>
//! <br>
  Standard_EXPORT     TopoDS_Shape GetShapeToPosition() const;
  //! This methode stores the shape to position. <br>
//! <br>
  Standard_EXPORT     Standard_Integer PositionShape(const TopoDS_Shape& ShapeToPosition) ;
  
//!   compute the isobarycentre of all vertexes of a shape <br>
//! <br>
//! <br>
  Standard_EXPORT     gp_Pnt IsoBarycentre(const TopoDS_Shape& S) const;
  
  Standard_EXPORT     Standard_Boolean IsOverConstrained() const;





protected:





private:

  //! Check if an Axis Constraint is already aligned with <br>
//!          a previous one defined before <br>
//! <br>
  Standard_EXPORT     Standard_Boolean AxisAlignedWithPrevious(const ShapePlacement_ListOfConstraint& ReferenceList,const ShapePlacement_Constraint& AConstraint) ;
  
//!    makes all the relevant calculations for sorting out the <br>
//!    case we are in the above cases <br>
//! <br>
  Standard_EXPORT     Standard_Integer CheckWhichCase() ;
  
//!   finds out from the constraints in which of the above cases <br>
//!   we are : <br>
//! <br>
//! <br>
  Standard_EXPORT     void ComputeWhichCase(Standard_Integer& ResultFlag) const;
  
//!   solves the following case that is : there are at least 2 constraint <br>
//!   whose  equation are of type PLANE_PLACEMENT which are compatible <br>
//! <br>
//! <br>
  Standard_EXPORT     void SolveCase1() ;
  
//!   solves the following case that is : there is  1 constraint <br>
//!   whose  equation is of type AXIS_AXIS_PLACEMENT and <br>
//!   only other contraint that are of  type PLANE_PLACEMENT <br>
//!   which are compatible <br>
//! <br>
  Standard_EXPORT     void SolveCase2() ;
  
//!  solves the following case that is : there are at least 2 constraint <br>
//!   whose  equation are of type AXIS_AXIS_PLACEMENT which are compatible <br>
//! <br>
  Standard_EXPORT     void SolveCase3() ;
  
//!  solves    the  following    case  :   there    is exactly   one <br>
//!  constraint whose equation is of type PLANE_PLACEMENT <br>
//!  and at least one constraint whose equation is of type LINE_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase4() ;
  
//!  solves  the following   case : there  is one <br>
//!  equation are of type AXIS_AXIS_PLACEMENT  and at least 1 equations <br>
//!  that are linearly independant that  are of type LINE_PLACEMENT <br>
//!  or ANGULAR_PLACEMENT  which give at least a solution <br>
//! <br>
  Standard_EXPORT     void SolveCase5() ;
  
//!  solves  the  following case :  there  are  no constraint whose <br>
//!  equation  is of type  PLANE_PLACEMENT  and there are exactly 2 <br>
//!  constraint of type LINE_PLACEMENT or ANGULAR_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase6() ;
  
//!  solves  the  following case :  there  are  no constraint whose <br>
//!  equation  is of type  PLANE_PLACEMENT  and there are exactly 2 <br>
//!  constraint of type LINE_PLACEMENT or ANGULAR_PLACEMENT <br>
  Standard_EXPORT     void SolveCase7() ;
  
//!  solves  the  following case :  there are 1, 2 or 3 constraints whose <br>
//!  equation is of type PLANE_AXIS_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase8() ;
  
//!  solves  the  following case :  there are 1 or 2 constraints whose <br>
//!  equation is of type ANGULAR_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase9() ;
  
//!  solves  the  following case :  there are 1 constraint whose <br>
//!  equation is of type ANGULAR_PLACEMENT and 1 of type PLAN_PLACEMENT <br>
//!  or AXIS_AXIS_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase10() ;
  
//!  solves  the  following case :  there are 1 constraint whose <br>
//!  equation is of type ANGULAR_PLACEMENT and 1 of type PLANE_AXIS_PLACEMENT <br>
//! <br>
  Standard_EXPORT     void SolveCase11() ;


Standard_Boolean myHasSolution;
gp_Trsf myTrsf;
Handle_TColStd_HArray1OfInteger myEquationStatus;
Handle_TColStd_HArray1OfInteger myEquationOrientation;
Standard_Real myAngularTolerance;
ShapePlacement_ListOfConstraint myConstraints;
TopoDS_Shape myShapeToPosition;
TopTools_IndexedMapOfShape mySubShapes;
Standard_Boolean myIsOverConstrained;


};





// other Inline functions and methods (like "C++: function call" methods)


#endif
